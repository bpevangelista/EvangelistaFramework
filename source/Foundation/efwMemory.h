/**
 * Copyright (C) 2012 Bruno P. Evangelista. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#pragma once

#include "Foundation/efwPlatform.h"

#include <string.h>

namespace efw
{

inline int16_t efwRevert16(int16_t value)
{
	return (value >> 8) | (value << 8);
}

inline uint16_t efwRevert16(uint16_t value)
{
	return (value >> 8) | (value << 8);
}

inline int32_t efwRevert32(int32_t value)
{
	return (
		(value >> 24) | 
		(value << 24) |
		((value & 0x00FF0000) >> 8) |
		((value & 0x0000FF00) << 8) );
}

inline uint32_t efwRevert32(uint32_t value)
{
	return (
		(value >> 24) | 
		(value << 24) |
		((value & 0x00FF0000) >> 8) |
		((value & 0x0000FF00) << 8) );
}

// Those endian swap functions can be enabled per-platform
#if defined(PLATFORM_BIGENDIAN)
inline int16_t efwEndianSwapIfRequired(int16_t value) { return efwRevert16(value); }
inline uint16_t efwEndianSwapIfRequired(uint16_t value) {	return efwRevert16(value); }
inline int32_t efwEndianSwapIfRequired(int32_t value) { return efwRevert32(value); }
inline uint32_t efwEndianSwapIfRequired(uint32_t value) { return efwRevert32(value); }
#else
inline int16_t efwEndianSwapIfRequired(int16_t value) { return value; }
inline uint16_t efwEndianSwapIfRequired(uint16_t value) { return value; }
inline int32_t efwEndianSwapIfRequired(int32_t value) { return value; }
inline uint32_t efwEndianSwapIfRequired(uint32_t value) { return value; }
#endif


//inline uint32_t efwAlign(uint32_t alignment, uint32_t value)
//{
//	return (value + (alignment - 1)) & ( ~(alignment - 1) );
//}

const int64_t kHashEncodeStart = 0xBB40E64DA205B064L;
const int64_t kHashEncodeMul = 7664345821815920749L;
const int64_t kHashEncodeTable[] = { 
	3384252087292693120L, 7658340761471042879L, 1975387214912723373L, 2603387121167513185L, 7955704334324082719L, 4951966396222582764L, 1935682104586355207L, 6149608258013166992L, 1963511788992967262L, 4004151029928389236L, 5050029776704688880L, 
	8529485927383078590L, 8613823721534148838L, 4303291881702922390L, 8439222822295121193L, 3763206986438027582L, 2596303889243731492L, 681960527038275460L, 4364580274495492623L, 481874634181996346L, 8002333243745701548L, 9113132328987046999L, 
	6057799133318560692L, 8606433932215434772L, 6146801716562911349L, 5169939367329222461L, 2338542905482791069L, 8337762174347083367L, 6032923012962066022L, 2794172816550849597L, 3680591002757969331L, 7157794727782535768L, 2380181675661670348L, 
	1683975326027852692L, 3054096346931345199L, 9094639724630753188L, 5165740289933178426L, 6016147639349914519L, 6834982901599722994L, 869196316394424664L, 5790818068129405018L, 2923243901495369201L, 1927952238158118005L, 7898534270105963991L, 
	6536690982664195361L, 1522531251893289322L, 6281298436697382425L, 2134049886011811109L, 6779816858146360378L, 4466352476673609256L, 5506245717177743744L, 8370688940722867661L, 5950402231659206868L, 2740596622858724013L, 6077758538603660903L, 
	8107765289647150213L, 5550912090948937121L, 2103529775721302272L, 735852429235792480L, 3991612636623539836L, 7765229866230359318L, 7974922459700467979L, 3373755347886553299L, 6835849694402181226L, 5170010105877219440L, 2189397325721999831L, 
	3311269019826444364L, 7763665496041310212L, 8168997654894463929L, 676924096528400382L, 1645928743837015424L, 3718977088630352238L, 8512557215958669421L, 736990636615566479L, 7093789507680189388L, 820476512726395677L, 3310608852018395261L, 
	2206461713852202359L, 1028293669666921381L, 292470140970983882L, 3407177712667193873L, 8148834917058765222L, 4055302778135519693L, 1866164541091790815L, 7504142696214561908L, 9147813338862604480L, 4593575799351504349L, 3872146268781945204L, 
	9212195369704362918L, 8130935622078889498L, 4704290912093624957L, 3452450139934455429L, 2175833784808375474L, 5182121635869856747L, 947072620488964540L, 8777536604888934943L, 1604926472643158651L, 1601902836600247656L, 3255516947347990637L, 
	7603715920992722478L, 5429292584418031465L, 5328475453733817736L, 8603457317027751980L, 8331688783519387646L, 8151259327692043416L, 2074197644011742830L, 228043366947070998L, 5394125563201700103L, 1716522448495737926L, 4968805242799127942L, 
	5654955973464493198L, 6299477693149135197L, 6282024478491091987L, 6254261152854631297L, 2760485328023237103L, 6673469621133996237L, 6671353287741375747L, 3184412622242732034L, 3989300611660383383L, 4484041505073415316L, 8725917681335765686L, 
	6290516322038177211L, 6078576999658044538L, 4244658623676468451L, 5275378540960386657L, 5874861273728039195L, 602052646169467096L, 5911082725468547737L, 2488664662306163696L, 2219462566991633419L, 3784375072001683782L, 8277957979568871826L, 
	7181951517884999675L, 4729292117511730747L, 5189176825223149362L, 8596279234360171634L, 1801880359974414721L, 1031029563120211822L, 6277181699808242750L, 1473596004296254102L, 7357520328695342894L, 5166169461382624789L, 1819755500628153988L, 
	2325303038767592155L, 4890895331453580235L, 957725654802005839L, 4055235789178531573L, 752525368272123236L, 8701096627781701616L, 134137382320823348L, 2499277273595951668L, 7043204735320096760L, 8712684519084169712L, 5480121471580306384L, 
	3974418449247564511L, 3670520620196014665L, 385181785501509850L, 8466783564445749162L, 7660457070434498775L, 8119202433357245413L, 1134705843589140863L, 3007922858642178200L, 7506081115526167256L, 6815937092475493174L, 3809817462940404246L, 
	2734118554285981589L, 7005328938559659855L, 7613041502945735293L, 6271326941350474125L, 79417061850928947L, 1358544574183080872L, 6990585453769180577L, 2415664823484725426L, 1052905330090435694L, 1790670206496281833L, 3990814432347432094L, 
	7566786433331594285L, 5299341559223556130L, 5876184045157711271L, 4931959227121418943L, 1369905830691889335L, 3965915500307499973L, 7346184694501084273L, 3153450654563921734L, 1776977035459399461L, 3883956724367139684L, 4873290025543395872L, 
	1137979420910454503L, 3487277648637863952L, 6162296652330579884L, 4518440086228094436L, 1759845348030259192L, 766033596821483808L, 5910140299361472054L, 7950559425747757318L, 4674987994847849228L, 1713856910673093500L, 8597828047149402071L, 
	5285572492498558231L, 8465621435017216732L, 6043787594397375661L, 3570755367617501991L, 7600519872593991031L, 1757515141314184878L, 5060421274864174868L, 8996013710062016481L, 7048197056557546304L, 4939641476854581480L, 2991871127928749627L, 
	3938165595674547543L, 6253540331644638932L, 6790904990143613497L, 605773443082826769L, 3258599549280113058L, 4776663038973171737L, 6997709015229192795L, 2910461548707262799L, 3718081841056535804L, 6705493088028827295L, 6074628730924806536L, 
	1169612483016712799L, 2092127682606581491L, 131802186532318305L, 6322840384400835073L, 3510745603363896876L, 7604017798991726310L, 4575885038936654097L, 1435452598205295940L, 1911767372856898170L, 6482007255590164186L, 758477816216122730L, 
	3469542861783617706L, 4286944424366230875L, 9040770431595070617L, 8994118831444693180L, 1375489225233174152L, 5311806321970486819L, 3794102673291567104L, 3149618249613049244L, 7651365754513249876L, 5999008317355253364L, 8893410236366226055L, 
	4895618891824172786L, 2577157184610263046L, 7902147836595751868L, 3623903823806153621L, 4180896507414524301L, 7142656268699507244L, 7652252436314062380L, 6578087573846372992L, 1695957007652117075L, 5535542765137310587L, 5698399088438462142L, 
	1827043142074126360L, 8754378073218451928L, 6306108838017328104L };


inline int64_t efwHash64(const void* data, int32_t sizeInBytes)
{
	EFW_ASSERT(data != NULL);

	int64_t h = kHashEncodeStart;
	uint8_t* dataU8 = (uint8_t*)data;

	for (int32_t i=0; i < sizeInBytes; i++)
	{
		h = (h * kHashEncodeMul) ^ kHashEncodeTable[ dataU8[i] ];
	}

	return h;
}


inline int64_t efwHash64(const char* str)
{
	EFW_ASSERT(str != NULL);

	int64_t h = kHashEncodeStart;
	uint8_t* dataU8 = (uint8_t*)str;

	for (int32_t i=0; dataU8[i] != 0; i++)
	{
		h = (h * kHashEncodeMul) ^ kHashEncodeTable[ dataU8[i] ];
	}

	return h;
}

}